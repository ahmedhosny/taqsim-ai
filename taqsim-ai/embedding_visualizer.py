"""
Embedding Visualizer for MAEST Audio Embeddings

This script provides functions to:
1. Load audio embeddings generated by the MAEST model
2. Reduce their dimensionality using UMAP
3. Visualize the embeddings in a 2D plot with each track having its own color
"""

import glob
import os
import re

import matplotlib.pyplot as plt
import numpy as np
from matplotlib.colors import hsv_to_rgb
from umap import UMAP


def load_embeddings(embeddings_dir):
    """
    Load all embedding files from the specified directory.

    Args:
        embeddings_dir: Path to the directory containing embedding .npz files

    Returns:
        Dictionary with video IDs as keys and dictionaries of chunk embeddings as values
    """
    all_embeddings = {}

    # Find all .npz files in the embeddings directory
    embedding_files = glob.glob(
        os.path.join(embeddings_dir, "embeddings_youtube_*.npz")
    )

    for file_path in embedding_files:
        # Extract video ID from filename
        match = re.search(
            r"embeddings_youtube_([^.]+)\.npz", os.path.basename(file_path)
        )
        if match:
            video_id = match.group(1)

            # Load the embeddings
            try:
                embeddings = np.load(file_path)

                # Store embeddings by video ID
                all_embeddings[video_id] = {
                    key: embeddings[key] for key in embeddings.keys()
                }

                print(
                    f"Loaded embeddings for video {video_id} with {len(embeddings.keys())} chunks"
                )
            except Exception as e:
                print(f"Error loading embeddings from {file_path}: {e}")

    return all_embeddings


def prepare_embeddings_for_umap(all_embeddings, embedding_type="cls"):
    """
    Prepare embeddings for UMAP by extracting the specified embedding type.

    Args:
        all_embeddings: Dictionary of embeddings by video ID
        embedding_type: Which embedding type to use ('cls', 'dist', 'avg', or 'combined')

    Returns:
        Tuple of (embeddings array, labels array, video_ids array, colors array)
    """
    embeddings_list = []
    labels = []
    video_ids = []

    # Generate colors for each video ID
    colors = []

    for i, video_id in enumerate(all_embeddings.keys()):
        # Create a unique color for this video based on HSV color space
        hue = i / len(all_embeddings)
        color = hsv_to_rgb((hue, 0.8, 0.9))

        video_embeddings = all_embeddings[video_id]
        for chunk_key, embedding in video_embeddings.items():
            # Extract chunk number from key (e.g., 'chunk_1' -> 1)
            chunk_num = int(chunk_key.split("_")[1])

            # Each embedding is shape [3, 768] where:
            # embedding[0] = CLS token embedding
            # embedding[1] = DIST token embedding
            # embedding[2] = Average of other token embeddings
            if embedding_type == "cls":
                embeddings_list.append(embedding[0])
            elif embedding_type == "dist":
                embeddings_list.append(embedding[1])
            elif embedding_type == "avg":
                embeddings_list.append(embedding[2])
            elif embedding_type == "combined":
                # Concatenate all three embeddings
                embeddings_list.append(
                    np.concatenate([embedding[0], embedding[1], embedding[2]])
                )

            labels.append(chunk_num)
            video_ids.append(video_id)
            colors.append(color)

    return (
        np.array(embeddings_list),
        np.array(labels),
        np.array(video_ids),
        np.array(colors),
    )


def visualize_embeddings(
    embeddings_dir, embedding_type="cls", n_neighbors=15, min_dist=0.1, output_file=None
):
    """
    Load embeddings, reduce dimensionality with UMAP, and visualize in 2D.

    Args:
        embeddings_dir: Path to the directory containing embedding .npz files
        embedding_type: Which embedding type to use ('cls', 'dist', 'avg', or 'combined')
        n_neighbors: UMAP parameter for local neighborhood size
        min_dist: UMAP parameter for minimum distance between points
        output_file: Path to save the plot (if None, plot is displayed)
    """
    # Load all embeddings
    all_embeddings = load_embeddings(embeddings_dir)

    if not all_embeddings:
        print("No embeddings found in the specified directory.")
        return

    # Prepare embeddings for UMAP
    embeddings, labels, video_ids, colors = prepare_embeddings_for_umap(
        all_embeddings, embedding_type
    )

    # Reduce dimensionality with UMAP
    print(f"Reducing dimensionality with UMAP (embedding type: {embedding_type})...")
    reducer = UMAP(n_neighbors=n_neighbors, min_dist=min_dist, random_state=42)
    embedding_2d = reducer.fit_transform(embeddings)

    # Create the plot
    plt.figure(figsize=(12, 10))

    # Group points by video ID to draw arrows within each song
    video_id_groups = {}
    for i, vid in enumerate(video_ids):
        if vid not in video_id_groups:
            video_id_groups[vid] = []
        video_id_groups[vid].append((labels[i], embedding_2d[i], colors[i]))

    # Sort points within each group by chunk number
    for vid in video_id_groups:
        video_id_groups[vid].sort(key=lambda x: x[0])  # Sort by chunk number

    # Plot each point and draw arrows between consecutive chunks
    for vid, points in video_id_groups.items():
        # Draw arrows between consecutive points
        for j in range(len(points) - 1):
            chunk_num1, pos1, _ = points[j]
            chunk_num2, pos2, _ = points[j + 1]

            # Draw arrow from point j to point j+1
            plt.annotate(
                "",
                xy=(pos2[0], pos2[1]),  # End point
                xytext=(pos1[0], pos1[1]),  # Start point
                arrowprops=dict(
                    arrowstyle="->",
                    color="black",
                    lw=1.5,
                    alpha=0.7,
                ),
            )

        # Plot the points
        for chunk_num, pos, color in points:
            plt.scatter(
                pos[0],
                pos[1],
                color=color,
                s=120,  # Point size
                alpha=0.7,  # Transparency
                edgecolors="white",
                zorder=10,  # Ensure points are drawn on top of arrows
            )

            # Add chunk number as text label
            plt.text(
                pos[0],
                pos[1],
                str(chunk_num),
                fontsize=9,
                ha="center",
                va="center",
                color="black",
                fontweight="bold",
                zorder=11,  # Ensure text is drawn on top of points
            )

    # Create a legend for video IDs with song names
    unique_video_ids = list(set(video_ids))
    handles = []

    # Get the downloads directory to find song names
    script_dir = os.path.dirname(os.path.abspath(__file__))
    project_dir = os.path.dirname(script_dir)
    downloads_dir = os.path.join(project_dir, "data", "downloads")

    for i, vid in enumerate(unique_video_ids):
        # Get the color for this video ID
        idx = list(video_ids).index(vid)
        color = colors[idx]

        # Try to find the song name from the downloads directory
        song_name = "Unknown"
        try:
            # Look for files with this video ID in the filename
            # Format can be either:
            # 1. youtube_videoID_title.wav
            # 2. title_videoID.wav
            matching_files = [
                f
                for f in os.listdir(downloads_dir)
                if (
                    f.startswith(f"youtube_{vid}")
                    or f.endswith(f"_{vid}.wav")
                    or f.endswith(f"_{vid}.mp3")
                )
                and os.path.isfile(os.path.join(downloads_dir, f))
            ]

            if matching_files:
                file_name = matching_files[0]
                # Get the filename without extension
                song_name = os.path.splitext(file_name)[0]

                # Handle different filename formats
                if song_name.startswith(f"youtube_{vid}_"):
                    # Format: youtube_videoID_title
                    song_name = song_name[len(f"youtube_{vid}_") :]
                elif song_name.startswith(f"youtube_{vid}"):
                    # Format: youtube_videoID
                    song_name = song_name[len(f"youtube_{vid}") :]
                elif song_name.endswith(f"_{vid}"):
                    # Format: title_videoID
                    song_name = song_name[: -len(f"_{vid}")]

                print(f"Found song name for video {vid}: {song_name}")
        except Exception as e:
            print(f"Error finding song name for video {vid}: {e}")

        handle = plt.Line2D(
            [0],
            [0],
            marker="o",
            color="w",
            markerfacecolor=color,
            markersize=10,
            label=f"Video: {vid} - {song_name}",
        )
        handles.append(handle)

    plt.legend(handles=handles, title="Videos", loc="best")

    plt.title(f"UMAP Visualization of MAEST {embedding_type.upper()} Embeddings")
    plt.xlabel("UMAP Dimension 1")
    plt.ylabel("UMAP Dimension 2")
    plt.grid(alpha=0.3)

    # Save or show the plot
    if output_file:
        plt.savefig(output_file, dpi=300, bbox_inches="tight")
        print(f"Plot saved to {output_file}")
    else:
        plt.tight_layout()
        plt.show()


def visualize_all_embedding_types(embeddings_dir, output_dir=None):
    """
    Generate visualizations for all embedding types (CLS, DIST, AVG, Combined).

    Args:
        embeddings_dir: Path to the directory containing embedding .npz files
        output_dir: Directory to save the plots (if None, plots are displayed)
    """
    embedding_types = ["cls", "dist", "avg", "combined"]

    for embedding_type in embedding_types:
        print(f"\nVisualizing {embedding_type.upper()} embeddings...")

        if output_dir:
            os.makedirs(output_dir, exist_ok=True)
            output_file = os.path.join(
                output_dir, f"maest_{embedding_type}_embeddings.png"
            )
        else:
            output_file = None

        visualize_embeddings(
            embeddings_dir=embeddings_dir,
            embedding_type=embedding_type,
            output_file=output_file,
        )


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(
        description="Visualize MAEST audio embeddings using UMAP"
    )
    parser.add_argument(
        "--embeddings_dir", default=None, help="Directory containing embedding files"
    )
    parser.add_argument(
        "--output_dir", default=None, help="Directory to save visualization plots"
    )
    parser.add_argument(
        "--embedding_type",
        default="all",
        choices=["cls", "dist", "avg", "combined", "all"],
        help="Type of embedding to visualize",
    )

    args = parser.parse_args()

    # If embeddings_dir not specified, use default data/embeddings directory
    if args.embeddings_dir is None:
        # Get the project directory (one level up from the script)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_dir = os.path.dirname(script_dir)  # Just one level up
        args.embeddings_dir = os.path.join(project_dir, "data", "embeddings")

    # If output_dir not specified, use default data/visualizations directory
    if args.output_dir is None:
        # Get the project directory (one level up from the script)
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_dir = os.path.dirname(script_dir)  # Just one level up
        args.output_dir = os.path.join(project_dir, "data", "visualizations")

    # Create output directory if specified
    if args.output_dir:
        os.makedirs(args.output_dir, exist_ok=True)

    if args.embedding_type == "all":
        visualize_all_embedding_types(args.embeddings_dir, args.output_dir)
    else:
        if args.output_dir:
            output_file = os.path.join(
                args.output_dir, f"maest_{args.embedding_type}_embeddings.png"
            )
        else:
            output_file = None

        visualize_embeddings(
            embeddings_dir=args.embeddings_dir,
            embedding_type=args.embedding_type,
            output_file=output_file,
        )
